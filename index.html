<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aurora Watch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add Babel Standalone for in-browser JSX/TSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
          "react": "https://aistudiocdn.com/react@^19.2.0",
          "@google/genai": "https://aistudiocdn.com/@google/genai@^1.29.1",
          "recharts": "https://aistudiocdn.com/recharts@^3.4.1/es6/index.js"
        }
      }
    </script>
  </head>
  <body class="bg-gray-900">
    <div id="root"></div>
    <!-- This script loads the API key. See README.md for configuration. -->
    <script src="./env.js"></script>
    <!-- 
      All application JavaScript is consolidated here.
      By placing all code in a single script tag with type="text/babel", we ensure
      the in-browser Babel compiler transforms all JSX before the browser executes it.
      This resolves the "Unexpected token '<'" SyntaxError caused by the browser
      trying to parse JSX from imported modules as plain JavaScript.
    -->
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI, Type } from "@google/genai";
      import { RadialBarChart, RadialBar, PolarAngleAxis, ResponsiveContainer } from 'recharts';

      // --- Services ---
      let ai = null;
      const getAiClient = () => {
        if (!ai) {
          const apiKey = window.process?.env?.AURORA_API_KEY;
          if (!apiKey) {
            throw new Error("Gemini API key is not configured. Please follow the setup instructions in README.md.");
          }
          ai = new GoogleGenAI({ apiKey: apiKey });
        }
        return ai;
      };

      const auroraForecastSchema = {
        type: Type.OBJECT,
        properties: {
          viewingProbability: { type: Type.NUMBER, description: 'A number between 0 and 100 representing the percentage chance of seeing the aurora.' },
          kpIndex: { type: Type.NUMBER, description: 'A number representing the planetary K-index (0-9).' },
          cloudCover: { type: Type.NUMBER, description: 'A number between 0 and 100 representing the percentage of cloud cover.' },
          summary: { type: Type.STRING, description: 'A brief, user-friendly text summary of the viewing conditions, mentioning factors like moon phase and visibility.' },
        },
        required: ['viewingProbability', 'kpIndex', 'cloudCover', 'summary'],
      };

      const getAuroraForecast = async (latitude, longitude) => {
        const prompt = `Analyze meteorological and space weather data to provide a Northern Lights (Aurora Borealis) viewing forecast for the location with latitude ${latitude} and longitude ${longitude}. Consider all relevant factors, including geomagnetic activity (Kp-index), cloud cover, solar wind speed, and moon phase. Provide the output in a structured JSON format according to the provided schema. The summary should be concise and helpful for a casual observer.`;
        try {
          const client = getAiClient();
          const response = await client.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: { responseMimeType: "application/json", responseSchema: auroraForecastSchema },
          });
          const jsonText = response.text.trim();
          const parsedData = JSON.parse(jsonText);
          if (typeof parsedData.viewingProbability !== 'number' || typeof parsedData.kpIndex !== 'number' || typeof parsedData.cloudCover !== 'number' || typeof parsedData.summary !== 'string') {
            throw new Error("Received malformed data from API.");
          }
          return parsedData;
        } catch (error) {
          console.error("Error fetching from Gemini API:", error);
          const originalMessage = error instanceof Error ? error.message : String(error);
          throw new Error(`Could not retrieve forecast from Gemini API: ${originalMessage}`);
        }
      };

      // --- Components ---
      const ErrorMessage = ({ message }) => (
        <div className="w-full bg-red-900/50 border border-red-500 text-red-300 p-4 rounded-lg flex items-center space-x-3">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span>{message}</span>
        </div>
      );

      const LoadingSpinner = () => (
        <div className="flex flex-col items-center justify-center space-y-3">
          <svg className="animate-spin h-10 w-10 text-teal-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          <p className="text-gray-300">Fetching your aurora forecast...</p>
        </div>
      );

      const GaugeChart = ({ value }) => {
        const getColor = (val) => {
          if (val > 66) return '#4ade80'; // green-400
          if (val > 33) return '#facc15'; // yellow-400
          return '#f87171'; // red-400
        };
        const color = getColor(value);
        const data = [{ name: 'Probability', value: value, fill: color }];
        return (
          <div className="w-48 h-48 sm:w-56 sm:h-56 relative">
            <ResponsiveContainer width="100%" height="100%">
              <RadialBarChart innerRadius="70%" outerRadius="100%" data={data} startAngle={180} endAngle={0} barSize={20}>
                <PolarAngleAxis type="number" domain={[0, 100]} angleAxisId={0} tick={false} />
                <RadialBar background={{ fill: '#374151' }} dataKey="value" cornerRadius={10} angleAxisId={0} />
              </RadialBarChart>
            </ResponsiveContainer>
            <div className="absolute inset-0 flex flex-col items-center justify-center">
              <span className="text-4xl sm:text-5xl font-bold" style={{ color }}>{Math.round(value)}%</span>
              <span className="text-sm text-gray-400 mt-1">Viewing Chance</span>
            </div>
          </div>
        );
      };
      
      const InfoCard = ({ title, value, unit, icon }) => (
        <div className="bg-gray-800/50 p-4 rounded-lg flex items-center space-x-4 border border-gray-700">
          <div className="text-teal-400">{icon}</div>
          <div>
            <p className="text-sm text-gray-400">{title}</p>
            <p className="text-xl font-bold">{value}<span className="text-base font-normal text-gray-400 ml-1">{unit}</span></p>
          </div>
        </div>
      );

      const ForecastDisplay = ({ forecast }) => (
        <div className="w-full bg-white/10 p-6 rounded-2xl shadow-lg border border-white/20 backdrop-blur-md animate-fade-in">
          <div className="flex flex-col md:flex-row items-center justify-between gap-8">
            <div className="w-full md:w-1/2 flex justify-center">
              <GaugeChart value={forecast.viewingProbability} />
            </div>
            <div className="w-full md:w-1/2 space-y-4">
              <InfoCard title="KP Index" value={forecast.kpIndex} unit="(Geomagnetic Activity)" icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>} />
              <InfoCard title="Cloud Cover" value={forecast.cloudCover} unit="%" icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z" /></svg>} />
            </div>
          </div>
          <div className="mt-6 pt-6 border-t border-gray-700">
            <h3 className="text-lg font-semibold text-teal-300 mb-2">Summary</h3>
            <p className="text-gray-300">{forecast.summary}</p>
          </div>
        </div>
      );
      
      const LocationInput = ({ onForecastRequest, isLoading }) => {
        const [latitude, setLatitude] = useState('');
        const [longitude, setLongitude] = useState('');
        const [error, setError] = useState(null);

        const handleGeolocation = () => {
          if (!navigator.geolocation) {
            setError('Geolocation is not supported by your browser.');
            return;
          }
          setError(null);
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const lat = position.coords.latitude.toFixed(4);
              const lon = position.coords.longitude.toFixed(4);
              setLatitude(lat);
              setLongitude(lon);
            },
            () => { setError('Unable to retrieve your location.'); }
          );
        };

        const handleSubmit = (e) => {
          e.preventDefault();
          const latNum = parseFloat(latitude);
          const lonNum = parseFloat(longitude);
          if (isNaN(latNum) || isNaN(lonNum) || latNum < -90 || latNum > 90 || lonNum < -180 || lonNum > 180) {
            setError('Please enter valid latitude (-90 to 90) and longitude (-180 to 180).');
            return;
          }
          setError(null);
          onForecastRequest(latNum, lonNum);
        };

        return (
          <div className="w-full bg-white/10 p-6 rounded-2xl shadow-lg border border-white/20 backdrop-blur-md">
            <form onSubmit={handleSubmit} className="space-y-4">
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <input type="text" placeholder="Latitude (e.g., 64.83)" value={latitude} onChange={(e) => setLatitude(e.target.value)} disabled={isLoading} className="w-full p-3 bg-gray-800 border border-gray-600 rounded-lg focus:ring-2 focus:ring-teal-400 focus:border-teal-400 outline-none transition duration-200 placeholder-gray-500" />
                <input type="text" placeholder="Longitude (e.g., -147.71)" value={longitude} onChange={(e) => setLongitude(e.target.value)} disabled={isLoading} className="w-full p-3 bg-gray-800 border border-gray-600 rounded-lg focus:ring-2 focus:ring-teal-400 focus:border-teal-400 outline-none transition duration-200 placeholder-gray-500" />
              </div>
              {error && <p className="text-red-400 text-sm">{error}</p>}
              <div className="flex flex-col sm:flex-row gap-3">
                <button type="button" onClick={handleGeolocation} disabled={isLoading} className="flex-1 flex items-center justify-center gap-2 p-3 bg-gray-700 hover:bg-gray-600 text-white font-semibold rounded-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clipRule="evenodd" /></svg>
                  Use My Location
                </button>
                <button type="submit" disabled={isLoading} className="flex-1 flex items-center justify-center gap-2 p-3 bg-teal-500 hover:bg-teal-600 text-white font-bold rounded-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clipRule="evenodd" /></svg>
                  Get Forecast
                </button>
              </div>
            </form>
          </div>
        );
      };

      // --- Main App Component ---
      const App = () => {
        const [forecast, setForecast] = useState(null);
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);

        const handleForecastRequest = useCallback(async (latitude, longitude) => {
          setIsLoading(true);
          setError(null);
          setForecast(null);
          try {
            const data = await getAuroraForecast(latitude, longitude);
            setForecast(data);
          } catch (err) {
            setError(err instanceof Error ? `Failed to fetch forecast. ${err.message}. Please try again.` : 'An unknown error occurred.');
          } finally {
            setIsLoading(false);
          }
        }, []);

        const WelcomeMessage = () => (
          <div className="text-center p-8 bg-white/5 rounded-2xl backdrop-blur-sm border border-white/10 shadow-lg">
            <h2 className="text-2xl font-bold text-teal-300 mb-2">Welcome to Aurora Watch</h2>
            <p className="text-gray-300">Enter your coordinates or use your current location to get the Northern Lights viewing forecast.</p>
          </div>
        );

        return (
          <div className="min-h-screen bg-gray-900 text-white font-sans flex flex-col items-center p-4 selection:bg-teal-500 selection:text-white">
            <div className="absolute inset-0 bg-cover bg-center z-0 opacity-20" style={{backgroundImage: `url('https://picsum.photos/seed/aurora/1920/1080')`}}></div>
            <main className="w-full max-w-2xl mx-auto flex flex-col items-center z-10 space-y-8 flex-grow justify-center">
              <header className="text-center">
                <h1 className="text-5xl md:text-6xl font-extrabold tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-green-300 via-teal-300 to-purple-400">
                  Aurora Watch
                </h1>
                <p className="text-gray-400 mt-2 text-lg">Your personal Northern Lights forecast.</p>
              </header>
              <LocationInput onForecastRequest={handleForecastRequest} isLoading={isLoading} />
              <div className="w-full min-h-[300px] flex items-center justify-center">
                {isLoading && <LoadingSpinner />}
                {error && <ErrorMessage message={error} />}
                {forecast && <ForecastDisplay forecast={forecast} />}
                {!isLoading && !error && !forecast && <WelcomeMessage />}
              </div>
            </main>
            <footer className="text-center text-gray-500 text-sm p-4 z-10">
              <p>Powered by Gemini. Location data is not stored.</p>
            </footer>
          </div>
        );
      };

      // --- Mount the App ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
  </body>
</html>
